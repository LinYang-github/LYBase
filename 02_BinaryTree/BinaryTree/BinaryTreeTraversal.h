#ifndef Traversal_h__
#define Traversal_h__

#include "BinaryTreeStruct.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
/// <summary>	二叉树遍历.  </summary>
///
/// PreOrderTraversal_Re		先序遍历-递归方式
/// PreOrderTraversal_Stack		先序遍历-辅助栈方式
/// InOrderTraversal_Re			中序遍历-递归方式
/// InOrderTraversal_Stack		中序遍历-辅助栈方式
/// InOrderTraversal			
/// PostOrderTraversal_Re		后序遍历-递归方式
/// PostOrderTraversal_Stack	后序遍历-辅助栈方式
/// PostOrderTraversal_Stack_2	后序遍历-辅助栈方式2
/// LevelOrderTraversal			层序遍历
/// 
/// <remarks>	LinY, 2017/5/10. </remarks>
////////////////////////////////////////////////////////////////////////////////////////////////////

class BinaryTreeTraversal
{
public:
	BinaryTreeTraversal(void);
	~BinaryTreeTraversal(void);

public:

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	先序遍历-递归方式. </summary>
	///
	/// 尾递归：递归形式在函数末尾，在函数即将返回前
	///			需要用栈存储调用的信息，当数据规模较大时容易越出栈空间
	/// 
	/// <remarks>	LinY, 2017/5/10. </remarks>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	static void PreOrderTraversal_Re(BinTree BT);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	先序遍历-辅助栈方式. </summary>
	///
	/// a.遇到一个节点，访问它，然后把它压栈，并去遍历它的左子树
	/// b.当左子树遍历结束后，从栈顶弹出该节点并将其指向右儿子，继续a步骤
	/// c.当所有节点访问完即最后访问的树节点为空且栈空时，停止
	/// 
	/// <remarks>	LinY, 2017/5/10. </remarks>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	static void PreOrderTraversal_Stack(BinTree BT);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	中序遍历-递归方式. </summary>
	///
	/// <remarks>	LinY, 2017/5/10. </remarks>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	static void InOrderTraversal_Re(BinTree BT);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	中序遍历-辅助栈方式. </summary>
	/// 
	/// <remarks>	LinY, 2017/5/10. </remarks>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	static void InOrderTraversal_Stack(BinTree BT);

	static void InOrderTraversal(BinTree BT);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	后序遍历-递归方式. </summary>
	///
	/// <remarks>	LinY, 2017/5/10. </remarks>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	static void PostOrderTraversal_Re(BinTree BT);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	后序遍历-辅助栈方式. </summary>
	/// 
	/// 优点：代码较简洁，思路较清晰
	/// 缺点：需要用一个栈来存储树的所有节点，空间占用较大
	/// 
	/// <remarks>	LinY, 2017/5/10. </remarks>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	static void PostOrderTraversal_Stack(BinTree BT);
	static void PostOrderTraversal_Stack_2(BinTree BT);

	////////////////////////////////////////////////////////////////////////////////////////////////////
	/// <summary>	层序遍历. </summary>
	/// 
	/// 队列实现基本思路：
	/// 遍历从根节点开始，首先将根节点入队，然后执行循环：
	/// 节点出队，访问根节点，将左儿子入队，将右儿子入队，直到队列为空停止
	/// 
	/// <remarks>	LinY, 2017/5/10. </remarks>
	////////////////////////////////////////////////////////////////////////////////////////////////////

	static void LevelOrderTraversal(BinTree BT);
};

#endif // Traversal_h__
